package galtonwatson

import (
	"sort"

	"golang.org/x/exp/rand"
	"gonum.org/v1/gonum/stat/distuv"

	"github.com/tommyreddad/galtonwatson/stat/dist"
	"github.com/tommyreddad/galtonwatson/tree"
)

// GaltonWatson implements a conditioned Galton-Watson tree generator. The
// conditioned Galton-Watson tree is specified by an offspring distribution
// and a node count.
type GaltonWatson struct {
	// n is the number of nodes in the tree.
	n uint32

	// rander is an object implementing the method Rand which generates random
	// samples from the offspring distribution.
	rander distuv.Rander

	// offspringProb is the probability mass function of the offspring distribution.
	offspringProb      []float64
	backingMultinomial *dist.Multinomial

	src rand.Source
}

// NewGaltonWatsonFromRander returns a GaltonWatson which represents a
// conditioned Galton-Watson tree of a given size `n`, whose offspring
// distribution can be generated by the given `rander`.
func NewGaltonWatsonFromRander(n uint32, rander distuv.Rander, src rand.Source) *GaltonWatson {
	return &GaltonWatson{
		n:      n,
		rander: rander,
		src:    src,
	}
}

// NewGaltonWatson returns a GaltonWatson which represents a conditioned
// Galton-Watson tree of a given size `n`, whose offspring distribution is a
// given probability mass function `offspringProb`.
func NewGaltonWatson(n uint32, offspringProb []float64, src rand.Source) *GaltonWatson {
	backingMultinomial := &dist.Multinomial{
		N:            n,
		CategoryProb: offspringProb,
		Src:          src,
	}
	return &GaltonWatson{
		n:                  n,
		offspringProb:      offspringProb,
		backingMultinomial: backingMultinomial,
		src:                src,
	}
}

// generateXiFromRander will generate the Xi array of offspring counts based on
// a given Rander. Includes specific generators for special Randers.
func (gw *GaltonWatson) generateXiFromRander(rander distuv.Rander) []uint32 {
	Xi := make([]uint32, gw.n)
	switch rander.(type) {
	case *distuv.Poisson:
		// The conditional Poisson distribution here is distributed as
		// Multinomial(n-1; 1/n, ..., 1/n).
		for i := uint32(0); i < gw.n-1; i++ {
			u := uint32(distuv.UnitUniform.Rand() * float64(gw.n))
			Xi[u]++
		}
	case *dist.Geometric:
		// The conditional geometric distribution here is distributed uniformly
		// on the discrete simplex (k_1, ..., k_n) such that k_1 + ... + k_n = n - 1.
		spaces := make([]int, gw.n)
		for i := uint32(0); i < gw.n-1; i++ {
			spaces[i] = int(distuv.UnitUniform.Rand() * float64(gw.n))
		}
		// TODO: implement radix sort to make this linear time
		sort.Ints(spaces)
		for i := uint32(0); i < gw.n-1; i++ {
			Xi[i] = uint32(spaces[i+1] - spaces[i])
		}
	default:
		// Default to rejection method. This is the slowest and most naive option.
		for total := uint32(0); total != gw.n-1; {
			total = 0
			for i := uint32(0); i < gw.n; i++ {
				Xi[i] = uint32(rander.Rand())
				total += Xi[i]
			}
		}
	}
	return Xi
}

// Xi is the array of the number of offspring of the nodes in a Galton-Watson
// tree observed when traversed in breadth-first or depth-first order. The
// number of these offspring can be viewed as a conditioned multinomial random
// variable.
func (gw *GaltonWatson) generateXiFromMultinomial(m *dist.Multinomial) []uint32 {
	// Generate multinomial conditionally upon the total sum being n-1, by the rejection method.
	var mCond map[uint32]uint32
	for total := uint32(0); total != gw.n-1; {
		mCond = m.Rand()
		total = 0
		for k, v := range mCond {
			total += k * v
		}
	}

	// Compute the first pass at the Xi array of DFS-order offspring.
	Xi := make([]uint32, gw.n)
	{
		i := 0
		for k, v := range mCond {
			for j := uint32(0); j < v; j++ {
				Xi[i] = k
				i++
			}
		}
	}
	rand.Shuffle(int(gw.n), func(i, j int) {
		Xi[i], Xi[j] = Xi[j], Xi[i]
	})
	return Xi
}

// S is the array of the sequence of queue sizes observed when traversing a
// Galton-Watson tree in breadth-first order.
func (gw *GaltonWatson) generateSFromXi(Xi []uint32) ([]int32, uint32) {
	S := make([]int32, gw.n+1)
	S[0] = 1
	minIndex := uint32(1)
	for i := uint32(1); i < gw.n+1; i++ {
		S[i] = S[i-1] + int32(Xi[i-1]) - 1
		if S[i] < S[minIndex] {
			minIndex = i
		}
	}
	return S, minIndex
}

// Rand returns a random sample drawn from the distribution. The generation
// algorithm is due to Devroye (2011), see: http://luc.devroye.org/gw-simulation.pdf.
func (gw *GaltonWatson) Rand() *tree.Node {
	var Xi []uint32
	if gw.rander != nil {
		// Prioritize the rander if specified.
		Xi = gw.generateXiFromRander(gw.rander)
	} else {
		// If no rander is specified, the offspringProb must be present.
		Xi = gw.generateXiFromMultinomial(gw.backingMultinomial)
	}

	// Compute the S array and keep track of the first minimum encounter.
	_, minIndex := gw.generateSFromXi(Xi)

	// Rotate Xi according to Dvoretzky-Motzkin.
	Xi = append(Xi[minIndex:gw.n], Xi[0:minIndex]...)

	// Build the tree using the correct Xi in DFS order.
	rootNode := tree.New(0)
	{
		nodeCount := 0
		traversalCount := 0
		currNode := rootNode
		dfsStack := []*tree.Node{currNode}
		for len(dfsStack) > 0 {
			currNode = dfsStack[len(dfsStack)-1]
			dfsStack = dfsStack[:len(dfsStack)-1]
			for i := uint32(0); i < Xi[traversalCount]; i++ {
				nodeCount++
				newNode := tree.New(nodeCount)
				currNode.AppendChild(newNode)
				dfsStack = append(dfsStack, newNode)
			}
			traversalCount++
		}
	}
	return rootNode
}
